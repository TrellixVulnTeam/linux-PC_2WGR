# 复习

### 计算机网络

##### socket和epoll的区别

都是阻塞IO

select的缺点：

1.支持的fd数量有限

单个进程能够监视的文件描述符的数量存在最大限制，通常是1024，虽然可以更改，但是由于select采用轮询的方式扫描文件描述符，文件描述符越多，性能越差。

内核文件中的 #define	_FD_SETSIZE 1024

2.每次调用select，都会把fd从用户态拷贝到内存态

内核/用户空间内存拷贝问题，select需要复制大量的句柄数据结构，产生巨大的开销。

句柄：带有计数功能的指针，和普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的应用标识，该标识可以重新被系统定位到内存地址上，这种间接访问对象的模式增强了系统对引用对象的控制（类似与于封装），通俗的说就是我们能调用句柄所提供的服务，只能在句柄封装好的操作范围内进行操作

3.因为使用的是轮询的方式，需要的内核遍历传进的所有fd。

最后 select只提供一个函数-select， 而epoll提供三个函数，epoll_create, epoll_ctl, epoll_wait。

· epoll_create()建立一个句柄

· epoll_ctl是注册要监听的事件类型

· epoll_wait等待事件的产生

epoll的优点

1.epoll没有fd是数目限制，最大上限为最大可以打开文件的数目，这个数字一般远大于2048,1GB内存可以支持10万左右，具体可以cat/proc/sys/fs/file-max来查看

2.对于重复把fd从用户态拷贝到内存态，epoll会在ctl时，每次注册新的时间到epoll句柄中时，会拷贝所有的fd到内核，而不是在epoll_wait时重复拷贝。epoll保整每个fd在整个过程中只会拷贝一次。

3.对于轮询方式遍历所有fd，epoll的解决方案不会向select那样每次把current轮流加入fd对应的设备等待队列中，而只在ctl时把current挂一遍，并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，回调函数就会把就绪的fd加入一个就绪链表。

wait的实际工作就是在这个就绪链表中查看有没有就绪的fd